// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'm_unit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MUnitTearOff {
  const _$MUnitTearOff();

  NoUnit noUnit() {
    return const NoUnit();
  }

  KG kg() {
    return const KG();
  }

  KM km() {
    return const KM();
  }

  METER meter() {
    return const METER();
  }

  TIMES times() {
    return const TIMES();
  }
}

/// @nodoc
const $MUnit = _$MUnitTearOff();

/// @nodoc
mixin _$MUnit {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noUnit,
    required TResult Function() kg,
    required TResult Function() km,
    required TResult Function() meter,
    required TResult Function() times,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noUnit,
    TResult Function()? kg,
    TResult Function()? km,
    TResult Function()? meter,
    TResult Function()? times,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoUnit value) noUnit,
    required TResult Function(KG value) kg,
    required TResult Function(KM value) km,
    required TResult Function(METER value) meter,
    required TResult Function(TIMES value) times,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoUnit value)? noUnit,
    TResult Function(KG value)? kg,
    TResult Function(KM value)? km,
    TResult Function(METER value)? meter,
    TResult Function(TIMES value)? times,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MUnitCopyWith<$Res> {
  factory $MUnitCopyWith(MUnit value, $Res Function(MUnit) then) =
      _$MUnitCopyWithImpl<$Res>;
}

/// @nodoc
class _$MUnitCopyWithImpl<$Res> implements $MUnitCopyWith<$Res> {
  _$MUnitCopyWithImpl(this._value, this._then);

  final MUnit _value;
  // ignore: unused_field
  final $Res Function(MUnit) _then;
}

/// @nodoc
abstract class $NoUnitCopyWith<$Res> {
  factory $NoUnitCopyWith(NoUnit value, $Res Function(NoUnit) then) =
      _$NoUnitCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoUnitCopyWithImpl<$Res> extends _$MUnitCopyWithImpl<$Res>
    implements $NoUnitCopyWith<$Res> {
  _$NoUnitCopyWithImpl(NoUnit _value, $Res Function(NoUnit) _then)
      : super(_value, (v) => _then(v as NoUnit));

  @override
  NoUnit get _value => super._value as NoUnit;
}

/// @nodoc

class _$NoUnit implements NoUnit {
  const _$NoUnit();

  @override
  String toString() {
    return 'MUnit.noUnit()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoUnit);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noUnit,
    required TResult Function() kg,
    required TResult Function() km,
    required TResult Function() meter,
    required TResult Function() times,
  }) {
    return noUnit();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noUnit,
    TResult Function()? kg,
    TResult Function()? km,
    TResult Function()? meter,
    TResult Function()? times,
    required TResult orElse(),
  }) {
    if (noUnit != null) {
      return noUnit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoUnit value) noUnit,
    required TResult Function(KG value) kg,
    required TResult Function(KM value) km,
    required TResult Function(METER value) meter,
    required TResult Function(TIMES value) times,
  }) {
    return noUnit(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoUnit value)? noUnit,
    TResult Function(KG value)? kg,
    TResult Function(KM value)? km,
    TResult Function(METER value)? meter,
    TResult Function(TIMES value)? times,
    required TResult orElse(),
  }) {
    if (noUnit != null) {
      return noUnit(this);
    }
    return orElse();
  }
}

abstract class NoUnit implements MUnit {
  const factory NoUnit() = _$NoUnit;
}

/// @nodoc
abstract class $KGCopyWith<$Res> {
  factory $KGCopyWith(KG value, $Res Function(KG) then) =
      _$KGCopyWithImpl<$Res>;
}

/// @nodoc
class _$KGCopyWithImpl<$Res> extends _$MUnitCopyWithImpl<$Res>
    implements $KGCopyWith<$Res> {
  _$KGCopyWithImpl(KG _value, $Res Function(KG) _then)
      : super(_value, (v) => _then(v as KG));

  @override
  KG get _value => super._value as KG;
}

/// @nodoc

class _$KG implements KG {
  const _$KG();

  @override
  String toString() {
    return 'MUnit.kg()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is KG);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noUnit,
    required TResult Function() kg,
    required TResult Function() km,
    required TResult Function() meter,
    required TResult Function() times,
  }) {
    return kg();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noUnit,
    TResult Function()? kg,
    TResult Function()? km,
    TResult Function()? meter,
    TResult Function()? times,
    required TResult orElse(),
  }) {
    if (kg != null) {
      return kg();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoUnit value) noUnit,
    required TResult Function(KG value) kg,
    required TResult Function(KM value) km,
    required TResult Function(METER value) meter,
    required TResult Function(TIMES value) times,
  }) {
    return kg(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoUnit value)? noUnit,
    TResult Function(KG value)? kg,
    TResult Function(KM value)? km,
    TResult Function(METER value)? meter,
    TResult Function(TIMES value)? times,
    required TResult orElse(),
  }) {
    if (kg != null) {
      return kg(this);
    }
    return orElse();
  }
}

abstract class KG implements MUnit {
  const factory KG() = _$KG;
}

/// @nodoc
abstract class $KMCopyWith<$Res> {
  factory $KMCopyWith(KM value, $Res Function(KM) then) =
      _$KMCopyWithImpl<$Res>;
}

/// @nodoc
class _$KMCopyWithImpl<$Res> extends _$MUnitCopyWithImpl<$Res>
    implements $KMCopyWith<$Res> {
  _$KMCopyWithImpl(KM _value, $Res Function(KM) _then)
      : super(_value, (v) => _then(v as KM));

  @override
  KM get _value => super._value as KM;
}

/// @nodoc

class _$KM implements KM {
  const _$KM();

  @override
  String toString() {
    return 'MUnit.km()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is KM);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noUnit,
    required TResult Function() kg,
    required TResult Function() km,
    required TResult Function() meter,
    required TResult Function() times,
  }) {
    return km();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noUnit,
    TResult Function()? kg,
    TResult Function()? km,
    TResult Function()? meter,
    TResult Function()? times,
    required TResult orElse(),
  }) {
    if (km != null) {
      return km();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoUnit value) noUnit,
    required TResult Function(KG value) kg,
    required TResult Function(KM value) km,
    required TResult Function(METER value) meter,
    required TResult Function(TIMES value) times,
  }) {
    return km(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoUnit value)? noUnit,
    TResult Function(KG value)? kg,
    TResult Function(KM value)? km,
    TResult Function(METER value)? meter,
    TResult Function(TIMES value)? times,
    required TResult orElse(),
  }) {
    if (km != null) {
      return km(this);
    }
    return orElse();
  }
}

abstract class KM implements MUnit {
  const factory KM() = _$KM;
}

/// @nodoc
abstract class $METERCopyWith<$Res> {
  factory $METERCopyWith(METER value, $Res Function(METER) then) =
      _$METERCopyWithImpl<$Res>;
}

/// @nodoc
class _$METERCopyWithImpl<$Res> extends _$MUnitCopyWithImpl<$Res>
    implements $METERCopyWith<$Res> {
  _$METERCopyWithImpl(METER _value, $Res Function(METER) _then)
      : super(_value, (v) => _then(v as METER));

  @override
  METER get _value => super._value as METER;
}

/// @nodoc

class _$METER implements METER {
  const _$METER();

  @override
  String toString() {
    return 'MUnit.meter()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is METER);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noUnit,
    required TResult Function() kg,
    required TResult Function() km,
    required TResult Function() meter,
    required TResult Function() times,
  }) {
    return meter();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noUnit,
    TResult Function()? kg,
    TResult Function()? km,
    TResult Function()? meter,
    TResult Function()? times,
    required TResult orElse(),
  }) {
    if (meter != null) {
      return meter();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoUnit value) noUnit,
    required TResult Function(KG value) kg,
    required TResult Function(KM value) km,
    required TResult Function(METER value) meter,
    required TResult Function(TIMES value) times,
  }) {
    return meter(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoUnit value)? noUnit,
    TResult Function(KG value)? kg,
    TResult Function(KM value)? km,
    TResult Function(METER value)? meter,
    TResult Function(TIMES value)? times,
    required TResult orElse(),
  }) {
    if (meter != null) {
      return meter(this);
    }
    return orElse();
  }
}

abstract class METER implements MUnit {
  const factory METER() = _$METER;
}

/// @nodoc
abstract class $TIMESCopyWith<$Res> {
  factory $TIMESCopyWith(TIMES value, $Res Function(TIMES) then) =
      _$TIMESCopyWithImpl<$Res>;
}

/// @nodoc
class _$TIMESCopyWithImpl<$Res> extends _$MUnitCopyWithImpl<$Res>
    implements $TIMESCopyWith<$Res> {
  _$TIMESCopyWithImpl(TIMES _value, $Res Function(TIMES) _then)
      : super(_value, (v) => _then(v as TIMES));

  @override
  TIMES get _value => super._value as TIMES;
}

/// @nodoc

class _$TIMES implements TIMES {
  const _$TIMES();

  @override
  String toString() {
    return 'MUnit.times()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TIMES);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noUnit,
    required TResult Function() kg,
    required TResult Function() km,
    required TResult Function() meter,
    required TResult Function() times,
  }) {
    return times();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noUnit,
    TResult Function()? kg,
    TResult Function()? km,
    TResult Function()? meter,
    TResult Function()? times,
    required TResult orElse(),
  }) {
    if (times != null) {
      return times();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoUnit value) noUnit,
    required TResult Function(KG value) kg,
    required TResult Function(KM value) km,
    required TResult Function(METER value) meter,
    required TResult Function(TIMES value) times,
  }) {
    return times(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoUnit value)? noUnit,
    TResult Function(KG value)? kg,
    TResult Function(KM value)? km,
    TResult Function(METER value)? meter,
    TResult Function(TIMES value)? times,
    required TResult orElse(),
  }) {
    if (times != null) {
      return times(this);
    }
    return orElse();
  }
}

abstract class TIMES implements MUnit {
  const factory TIMES() = _$TIMES;
}
